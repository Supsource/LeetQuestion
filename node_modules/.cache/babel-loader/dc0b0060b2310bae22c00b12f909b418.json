{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport isString from 'lodash/isString';\nimport isNumber from 'lodash/isNumber';\nimport adjustCaretPosition from './adjustCaretPosition';\nimport conformToMask from './conformToMask';\nimport { convertMaskToPlaceholder, processCaretTraps, defaultPlaceholderChar } from './utilities';\nvar emptyString = '';\nvar strNone = 'none';\nvar strObject = 'object';\nvar isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\nvar defer = typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame : setTimeout;\nexport default function createTextMaskInputElement(config) {\n  // Anything that we will need to keep between `update` calls, we will store in this `state` object.\n  var state = {\n    previousConformedValue: undefined,\n    previousPlaceholder: undefined\n  };\n  return {\n    state: state,\n    // `update` is called by framework components whenever they want to update the `value` of the input element.\n    // The caller can send a `rawValue` to be conformed and set on the input element. However, the default use-case\n    // is for this to be read from the `inputElement` directly.\n    update: function update(rawValue, _temp) {\n      var _pipeResults, _pipeResults2;\n\n      var _ref = _temp === void 0 ? config : _temp,\n          inputElement = _ref.inputElement,\n          providedMask = _ref.mask,\n          guide = _ref.guide,\n          pipe = _ref.pipe,\n          _ref$placeholderChar = _ref.placeholderChar,\n          placeholderChar = _ref$placeholderChar === void 0 ? defaultPlaceholderChar : _ref$placeholderChar,\n          _ref$keepCharPosition = _ref.keepCharPositions,\n          keepCharPositions = _ref$keepCharPosition === void 0 ? false : _ref$keepCharPosition,\n          _ref$showMask = _ref.showMask,\n          showMask = _ref$showMask === void 0 ? false : _ref$showMask; // if `rawValue` is `undefined`, read from the `inputElement`\n\n\n      if (typeof rawValue === 'undefined') {\n        rawValue = inputElement.value;\n      } // If `rawValue` equals `state.previousConformedValue`, we don't need to change anything. So, we return.\n      // This check is here to handle controlled framework components that repeat the `update` call on every render.\n\n\n      if (rawValue === state.previousConformedValue) {\n        return;\n      } // Text Mask accepts masks that are a combination of a `mask` and a `pipe` that work together. If such a `mask` is\n      // passed, we destructure it below, so the rest of the code can work normally as if a separate `mask` and a `pipe`\n      // were passed.\n\n\n      if (typeof providedMask === strObject && providedMask.pipe !== undefined && providedMask.mask !== undefined) {\n        pipe = providedMask.pipe;\n        providedMask = providedMask.mask;\n      } // The `placeholder` is an essential piece of how Text Mask works. For a mask like `(111)`, the placeholder would\n      // be `(___)` if the `placeholderChar` is set to `_`.\n\n\n      var placeholder; // We don't know what the mask would be yet. If it is an array, we take it as is, but if it's a function, we will\n      // have to call that function to get the mask array.\n\n      var mask; // If the provided mask is an array, we can call `convertMaskToPlaceholder` here once and we'll always have the\n      // correct `placeholder`.\n\n      if (providedMask instanceof Array) {\n        placeholder = convertMaskToPlaceholder(providedMask, placeholderChar);\n      } // In framework components that support reactivity, it's possible to turn off masking by passing\n      // `false` for `mask` after initialization. See https://github.com/text-mask/text-mask/pull/359\n\n\n      if (providedMask === false) {\n        return;\n      } // We check the provided `rawValue` before moving further.\n      // If it's something we can't work with `getSafeRawValue` will throw.\n\n\n      var safeRawValue = getSafeRawValue(rawValue); // `selectionEnd` indicates to us where the caret position is after the user has typed into the input\n\n      var currentCaretPosition = inputElement.selectionEnd; // We need to know what the `previousConformedValue` and `previousPlaceholder` is from the previous `update` call\n\n      var previousConformedValue = state.previousConformedValue,\n          previousPlaceholder = state.previousPlaceholder;\n      var caretTrapIndexes; // If the `providedMask` is a function. We need to call it at every `update` to get the `mask` array.\n      // Then we also need to get the `placeholder`\n\n      if (typeof providedMask === 'function') {\n        mask = providedMask(safeRawValue, {\n          currentCaretPosition: currentCaretPosition,\n          previousConformedValue: previousConformedValue,\n          placeholderChar: placeholderChar\n        }); // disable masking if `mask` is `false`\n\n        if (mask === false) {\n          return;\n        } // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n        // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask and return\n        // the indexes of the caret traps.\n\n\n        var _processCaretTraps = processCaretTraps(mask),\n            maskWithoutCaretTraps = _processCaretTraps.maskWithoutCaretTraps,\n            indexes = _processCaretTraps.indexes;\n\n        mask = maskWithoutCaretTraps; // The processed mask is what we're interested in\n\n        caretTrapIndexes = indexes; // And we need to store these indexes because they're needed by `adjustCaretPosition`\n\n        placeholder = convertMaskToPlaceholder(mask, placeholderChar); // If the `providedMask` is not a function, we just use it as-is.\n      } else {\n        mask = providedMask;\n      } // The following object will be passed to `conformToMask` to determine how the `rawValue` will be conformed\n\n\n      var conformToMaskConfig = {\n        previousConformedValue: previousConformedValue,\n        guide: guide,\n        placeholderChar: placeholderChar,\n        pipe: pipe,\n        placeholder: placeholder,\n        currentCaretPosition: currentCaretPosition,\n        keepCharPositions: keepCharPositions\n      }; // `conformToMask` returns `conformedValue` as part of an object for future API flexibility\n\n      var _conformToMask = conformToMask(safeRawValue, mask, conformToMaskConfig),\n          conformedValue = _conformToMask.conformedValue; // The following few lines are to support the `pipe` feature.\n\n\n      var piped = typeof pipe === 'function';\n      var pipeResults = {}; // If `pipe` is a function, we call it.\n\n      if (piped) {\n        // `pipe` receives the `conformedValue` and the configurations with which `conformToMask` was called.\n        pipeResults = pipe(conformedValue, _extends({\n          rawValue: safeRawValue\n        }, conformToMaskConfig)); // `pipeResults` should be an object. But as a convenience, we allow the pipe author to just return `false` to\n        // indicate rejection. Or return just a string when there are no piped characters.\n        // If the `pipe` returns `false` or a string, the block below turns it into an object that the rest\n        // of the code can work with.\n\n        if (pipeResults === false) {\n          // If the `pipe` rejects `conformedValue`, we use the `previousConformedValue`, and set `rejected` to `true`.\n          pipeResults = {\n            value: previousConformedValue,\n            rejected: true\n          };\n        } else if (isString(pipeResults)) {\n          pipeResults = {\n            value: pipeResults\n          };\n        }\n      } // Before we proceed, we need to know which conformed value to use, the one returned by the pipe or the one\n      // returned by `conformToMask`.\n\n\n      var finalConformedValue = piped ? (_pipeResults = pipeResults) === null || _pipeResults === void 0 ? void 0 : _pipeResults.value : conformedValue; // After determining the conformed value, we will need to know where to set\n      // the caret position. `adjustCaretPosition` will tell us.\n\n      var adjustedCaretPosition = adjustCaretPosition({\n        previousConformedValue: previousConformedValue,\n        previousPlaceholder: previousPlaceholder,\n        conformedValue: finalConformedValue,\n        placeholder: placeholder,\n        rawValue: safeRawValue,\n        currentCaretPosition: currentCaretPosition,\n        placeholderChar: placeholderChar,\n        indexesOfPipedChars: (_pipeResults2 = pipeResults) === null || _pipeResults2 === void 0 ? void 0 : _pipeResults2.indexesOfPipedChars,\n        caretTrapIndexes: caretTrapIndexes\n      }); // Text Mask sets the input value to an empty string when the condition below is set. It provides a better UX.\n\n      var inputValueShouldBeEmpty = finalConformedValue === placeholder && adjustedCaretPosition === 0;\n      var emptyValue = showMask ? placeholder : emptyString;\n      var inputElementValue = inputValueShouldBeEmpty ? emptyValue : finalConformedValue;\n      state.previousConformedValue = inputElementValue; // store value for access for next time\n\n      state.previousPlaceholder = placeholder; // In some cases, this `update` method will be repeatedly called with a raw value that has already been conformed\n      // and set to `inputElement.value`. The below check guards against needlessly readjusting the input state.\n      // See https://github.com/text-mask/text-mask/issues/231\n\n      if (inputElement.value === inputElementValue) {\n        return;\n      }\n\n      inputElement.value = inputElementValue; // set the input value\n\n      safeSetSelection(inputElement, adjustedCaretPosition); // adjust caret position\n    }\n  };\n}\n\nfunction safeSetSelection(element, selectionPosition) {\n  if (document.activeElement === element) {\n    if (isAndroid) {\n      defer(function () {\n        return element.setSelectionRange(selectionPosition, selectionPosition, strNone);\n      }, 0);\n    } else {\n      element.setSelectionRange(selectionPosition, selectionPosition, strNone);\n    }\n  }\n}\n\nfunction getSafeRawValue(inputValue) {\n  if (isString(inputValue)) {\n    return inputValue;\n  } else if (isNumber(inputValue)) {\n    return String(inputValue);\n  } else if (inputValue === undefined || inputValue === null) {\n    return emptyString;\n  } else {\n    throw new Error(\"The 'value' provided to Text Mask needs to be a string or a number. The value received was:\\n\\n \" + JSON.stringify(inputValue));\n  }\n}","map":{"version":3,"sources":["/Users/supriyomal/Documents/GitHub/LeetQuestion/node_modules/rsuite/esm/MaskedInput/createTextMaskInputElement.js"],"names":["_extends","isString","isNumber","adjustCaretPosition","conformToMask","convertMaskToPlaceholder","processCaretTraps","defaultPlaceholderChar","emptyString","strNone","strObject","isAndroid","navigator","test","userAgent","defer","requestAnimationFrame","setTimeout","createTextMaskInputElement","config","state","previousConformedValue","undefined","previousPlaceholder","update","rawValue","_temp","_pipeResults","_pipeResults2","_ref","inputElement","providedMask","mask","guide","pipe","_ref$placeholderChar","placeholderChar","_ref$keepCharPosition","keepCharPositions","_ref$showMask","showMask","value","placeholder","Array","safeRawValue","getSafeRawValue","currentCaretPosition","selectionEnd","caretTrapIndexes","_processCaretTraps","maskWithoutCaretTraps","indexes","conformToMaskConfig","_conformToMask","conformedValue","piped","pipeResults","rejected","finalConformedValue","adjustedCaretPosition","indexesOfPipedChars","inputValueShouldBeEmpty","emptyValue","inputElementValue","safeSetSelection","element","selectionPosition","document","activeElement","setSelectionRange","inputValue","String","Error","JSON","stringify"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport isString from 'lodash/isString';\nimport isNumber from 'lodash/isNumber';\nimport adjustCaretPosition from './adjustCaretPosition';\nimport conformToMask from './conformToMask';\nimport { convertMaskToPlaceholder, processCaretTraps, defaultPlaceholderChar } from './utilities';\nvar emptyString = '';\nvar strNone = 'none';\nvar strObject = 'object';\nvar isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\nvar defer = typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame : setTimeout;\nexport default function createTextMaskInputElement(config) {\n  // Anything that we will need to keep between `update` calls, we will store in this `state` object.\n  var state = {\n    previousConformedValue: undefined,\n    previousPlaceholder: undefined\n  };\n  return {\n    state: state,\n    // `update` is called by framework components whenever they want to update the `value` of the input element.\n    // The caller can send a `rawValue` to be conformed and set on the input element. However, the default use-case\n    // is for this to be read from the `inputElement` directly.\n    update: function update(rawValue, _temp) {\n      var _pipeResults, _pipeResults2;\n\n      var _ref = _temp === void 0 ? config : _temp,\n          inputElement = _ref.inputElement,\n          providedMask = _ref.mask,\n          guide = _ref.guide,\n          pipe = _ref.pipe,\n          _ref$placeholderChar = _ref.placeholderChar,\n          placeholderChar = _ref$placeholderChar === void 0 ? defaultPlaceholderChar : _ref$placeholderChar,\n          _ref$keepCharPosition = _ref.keepCharPositions,\n          keepCharPositions = _ref$keepCharPosition === void 0 ? false : _ref$keepCharPosition,\n          _ref$showMask = _ref.showMask,\n          showMask = _ref$showMask === void 0 ? false : _ref$showMask;\n\n      // if `rawValue` is `undefined`, read from the `inputElement`\n      if (typeof rawValue === 'undefined') {\n        rawValue = inputElement.value;\n      } // If `rawValue` equals `state.previousConformedValue`, we don't need to change anything. So, we return.\n      // This check is here to handle controlled framework components that repeat the `update` call on every render.\n\n\n      if (rawValue === state.previousConformedValue) {\n        return;\n      } // Text Mask accepts masks that are a combination of a `mask` and a `pipe` that work together. If such a `mask` is\n      // passed, we destructure it below, so the rest of the code can work normally as if a separate `mask` and a `pipe`\n      // were passed.\n\n\n      if (typeof providedMask === strObject && providedMask.pipe !== undefined && providedMask.mask !== undefined) {\n        pipe = providedMask.pipe;\n        providedMask = providedMask.mask;\n      } // The `placeholder` is an essential piece of how Text Mask works. For a mask like `(111)`, the placeholder would\n      // be `(___)` if the `placeholderChar` is set to `_`.\n\n\n      var placeholder; // We don't know what the mask would be yet. If it is an array, we take it as is, but if it's a function, we will\n      // have to call that function to get the mask array.\n\n      var mask; // If the provided mask is an array, we can call `convertMaskToPlaceholder` here once and we'll always have the\n      // correct `placeholder`.\n\n      if (providedMask instanceof Array) {\n        placeholder = convertMaskToPlaceholder(providedMask, placeholderChar);\n      } // In framework components that support reactivity, it's possible to turn off masking by passing\n      // `false` for `mask` after initialization. See https://github.com/text-mask/text-mask/pull/359\n\n\n      if (providedMask === false) {\n        return;\n      } // We check the provided `rawValue` before moving further.\n      // If it's something we can't work with `getSafeRawValue` will throw.\n\n\n      var safeRawValue = getSafeRawValue(rawValue); // `selectionEnd` indicates to us where the caret position is after the user has typed into the input\n\n      var currentCaretPosition = inputElement.selectionEnd; // We need to know what the `previousConformedValue` and `previousPlaceholder` is from the previous `update` call\n\n      var previousConformedValue = state.previousConformedValue,\n          previousPlaceholder = state.previousPlaceholder;\n      var caretTrapIndexes; // If the `providedMask` is a function. We need to call it at every `update` to get the `mask` array.\n      // Then we also need to get the `placeholder`\n\n      if (typeof providedMask === 'function') {\n        mask = providedMask(safeRawValue, {\n          currentCaretPosition: currentCaretPosition,\n          previousConformedValue: previousConformedValue,\n          placeholderChar: placeholderChar\n        }); // disable masking if `mask` is `false`\n\n        if (mask === false) {\n          return;\n        } // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n        // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask and return\n        // the indexes of the caret traps.\n\n\n        var _processCaretTraps = processCaretTraps(mask),\n            maskWithoutCaretTraps = _processCaretTraps.maskWithoutCaretTraps,\n            indexes = _processCaretTraps.indexes;\n\n        mask = maskWithoutCaretTraps; // The processed mask is what we're interested in\n\n        caretTrapIndexes = indexes; // And we need to store these indexes because they're needed by `adjustCaretPosition`\n\n        placeholder = convertMaskToPlaceholder(mask, placeholderChar); // If the `providedMask` is not a function, we just use it as-is.\n      } else {\n        mask = providedMask;\n      } // The following object will be passed to `conformToMask` to determine how the `rawValue` will be conformed\n\n\n      var conformToMaskConfig = {\n        previousConformedValue: previousConformedValue,\n        guide: guide,\n        placeholderChar: placeholderChar,\n        pipe: pipe,\n        placeholder: placeholder,\n        currentCaretPosition: currentCaretPosition,\n        keepCharPositions: keepCharPositions\n      }; // `conformToMask` returns `conformedValue` as part of an object for future API flexibility\n\n      var _conformToMask = conformToMask(safeRawValue, mask, conformToMaskConfig),\n          conformedValue = _conformToMask.conformedValue; // The following few lines are to support the `pipe` feature.\n\n\n      var piped = typeof pipe === 'function';\n      var pipeResults = {}; // If `pipe` is a function, we call it.\n\n      if (piped) {\n        // `pipe` receives the `conformedValue` and the configurations with which `conformToMask` was called.\n        pipeResults = pipe(conformedValue, _extends({\n          rawValue: safeRawValue\n        }, conformToMaskConfig)); // `pipeResults` should be an object. But as a convenience, we allow the pipe author to just return `false` to\n        // indicate rejection. Or return just a string when there are no piped characters.\n        // If the `pipe` returns `false` or a string, the block below turns it into an object that the rest\n        // of the code can work with.\n\n        if (pipeResults === false) {\n          // If the `pipe` rejects `conformedValue`, we use the `previousConformedValue`, and set `rejected` to `true`.\n          pipeResults = {\n            value: previousConformedValue,\n            rejected: true\n          };\n        } else if (isString(pipeResults)) {\n          pipeResults = {\n            value: pipeResults\n          };\n        }\n      } // Before we proceed, we need to know which conformed value to use, the one returned by the pipe or the one\n      // returned by `conformToMask`.\n\n\n      var finalConformedValue = piped ? (_pipeResults = pipeResults) === null || _pipeResults === void 0 ? void 0 : _pipeResults.value : conformedValue; // After determining the conformed value, we will need to know where to set\n      // the caret position. `adjustCaretPosition` will tell us.\n\n      var adjustedCaretPosition = adjustCaretPosition({\n        previousConformedValue: previousConformedValue,\n        previousPlaceholder: previousPlaceholder,\n        conformedValue: finalConformedValue,\n        placeholder: placeholder,\n        rawValue: safeRawValue,\n        currentCaretPosition: currentCaretPosition,\n        placeholderChar: placeholderChar,\n        indexesOfPipedChars: (_pipeResults2 = pipeResults) === null || _pipeResults2 === void 0 ? void 0 : _pipeResults2.indexesOfPipedChars,\n        caretTrapIndexes: caretTrapIndexes\n      }); // Text Mask sets the input value to an empty string when the condition below is set. It provides a better UX.\n\n      var inputValueShouldBeEmpty = finalConformedValue === placeholder && adjustedCaretPosition === 0;\n      var emptyValue = showMask ? placeholder : emptyString;\n      var inputElementValue = inputValueShouldBeEmpty ? emptyValue : finalConformedValue;\n      state.previousConformedValue = inputElementValue; // store value for access for next time\n\n      state.previousPlaceholder = placeholder; // In some cases, this `update` method will be repeatedly called with a raw value that has already been conformed\n      // and set to `inputElement.value`. The below check guards against needlessly readjusting the input state.\n      // See https://github.com/text-mask/text-mask/issues/231\n\n      if (inputElement.value === inputElementValue) {\n        return;\n      }\n\n      inputElement.value = inputElementValue; // set the input value\n\n      safeSetSelection(inputElement, adjustedCaretPosition); // adjust caret position\n    }\n  };\n}\n\nfunction safeSetSelection(element, selectionPosition) {\n  if (document.activeElement === element) {\n    if (isAndroid) {\n      defer(function () {\n        return element.setSelectionRange(selectionPosition, selectionPosition, strNone);\n      }, 0);\n    } else {\n      element.setSelectionRange(selectionPosition, selectionPosition, strNone);\n    }\n  }\n}\n\nfunction getSafeRawValue(inputValue) {\n  if (isString(inputValue)) {\n    return inputValue;\n  } else if (isNumber(inputValue)) {\n    return String(inputValue);\n  } else if (inputValue === undefined || inputValue === null) {\n    return emptyString;\n  } else {\n    throw new Error(\"The 'value' provided to Text Mask needs to be a string or a number. The value received was:\\n\\n \" + JSON.stringify(inputValue));\n  }\n}"]},"metadata":{},"sourceType":"module"}