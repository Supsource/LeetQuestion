{"ast":null,"code":"/**\n * interactive elements should be skiped\n * */\nvar INTERACTIVE_ELEMENTS = ['A', 'BUTTON', 'INPUT', 'OPTION', 'TEXTAREA', 'SELECT'];\nexport function isContainInteractiveElement(targetNode) {\n  return INTERACTIVE_ELEMENTS.includes(targetNode.tagName) || targetNode.contentEditable === 'true';\n}\nexport function setInlineStyles(node, styles) {\n  if (node !== null && styles !== null) {\n    for (var _i = 0, _Object$entries = Object.entries(styles); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _Object$entries[_i],\n          key = _Object$entries$_i[0],\n          value = _Object$entries$_i[1];\n      node.style[key] = value;\n    }\n  }\n}\nexport function setTranslate3d(node, translate) {\n  setInlineStyles(node, {\n    transform: translate ? \"translate3d(\" + translate.x + \"px,\" + translate.y + \"px,0)\" : ''\n  });\n}\nexport function setTransitionDuration(node, duration) {\n  setInlineStyles(node, {\n    transitionDuration: duration ? duration + \"ms\" : ''\n  });\n}\n/**\n * find closest target node from source node\n * */\n\nexport function closestNode(sourceNode, judge) {\n  var currentNode = sourceNode;\n\n  while (currentNode) {\n    if (judge(currentNode)) {\n      return currentNode;\n    }\n\n    currentNode = currentNode.parentNode;\n  }\n\n  return null;\n}\nexport function getEdgeOffset(node, parent, offset) {\n  if (offset === void 0) {\n    offset = {\n      left: 0,\n      top: 0\n    };\n  }\n\n  if (!node || !parent) {\n    return {};\n  } // Get the actual offsetTop / offsetLeft value, no matter how deep the node is nested\n\n\n  var nodeOffset = {\n    left: offset.left + node.offsetLeft,\n    top: offset.top + node.offsetTop\n  };\n\n  if (node.parentNode === parent) {\n    return nodeOffset;\n  }\n\n  return getEdgeOffset(node.parentNode, parent, nodeOffset);\n}\nexport function getScrollingParent(el) {\n  return closestNode(el, function (el) {\n    var computedStyle = window.getComputedStyle(el);\n    var overflowRegex = /(auto|scroll)/;\n    var properties = ['overflow', 'overflowX', 'overflowY'];\n    return properties.some(function (property) {\n      return overflowRegex.test(computedStyle[property]);\n    });\n  });\n}","map":{"version":3,"sources":["/Users/supriyomal/Documents/GitHub/LeetQuestion/node_modules/rsuite/esm/List/helper/utils.js"],"names":["INTERACTIVE_ELEMENTS","isContainInteractiveElement","targetNode","includes","tagName","contentEditable","setInlineStyles","node","styles","_i","_Object$entries","Object","entries","length","_Object$entries$_i","key","value","style","setTranslate3d","translate","transform","x","y","setTransitionDuration","duration","transitionDuration","closestNode","sourceNode","judge","currentNode","parentNode","getEdgeOffset","parent","offset","left","top","nodeOffset","offsetLeft","offsetTop","getScrollingParent","el","computedStyle","window","getComputedStyle","overflowRegex","properties","some","property","test"],"mappings":"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","sourcesContent":["/**\n * interactive elements should be skiped\n * */\nvar INTERACTIVE_ELEMENTS = ['A', 'BUTTON', 'INPUT', 'OPTION', 'TEXTAREA', 'SELECT'];\nexport function isContainInteractiveElement(targetNode) {\n  return INTERACTIVE_ELEMENTS.includes(targetNode.tagName) || targetNode.contentEditable === 'true';\n}\nexport function setInlineStyles(node, styles) {\n  if (node !== null && styles !== null) {\n    for (var _i = 0, _Object$entries = Object.entries(styles); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _Object$entries[_i],\n          key = _Object$entries$_i[0],\n          value = _Object$entries$_i[1];\n      node.style[key] = value;\n    }\n  }\n}\nexport function setTranslate3d(node, translate) {\n  setInlineStyles(node, {\n    transform: translate ? \"translate3d(\" + translate.x + \"px,\" + translate.y + \"px,0)\" : ''\n  });\n}\nexport function setTransitionDuration(node, duration) {\n  setInlineStyles(node, {\n    transitionDuration: duration ? duration + \"ms\" : ''\n  });\n}\n/**\n * find closest target node from source node\n * */\n\nexport function closestNode(sourceNode, judge) {\n  var currentNode = sourceNode;\n\n  while (currentNode) {\n    if (judge(currentNode)) {\n      return currentNode;\n    }\n\n    currentNode = currentNode.parentNode;\n  }\n\n  return null;\n}\nexport function getEdgeOffset(node, parent, offset) {\n  if (offset === void 0) {\n    offset = {\n      left: 0,\n      top: 0\n    };\n  }\n\n  if (!node || !parent) {\n    return {};\n  } // Get the actual offsetTop / offsetLeft value, no matter how deep the node is nested\n\n\n  var nodeOffset = {\n    left: offset.left + node.offsetLeft,\n    top: offset.top + node.offsetTop\n  };\n\n  if (node.parentNode === parent) {\n    return nodeOffset;\n  }\n\n  return getEdgeOffset(node.parentNode, parent, nodeOffset);\n}\nexport function getScrollingParent(el) {\n  return closestNode(el, function (el) {\n    var computedStyle = window.getComputedStyle(el);\n    var overflowRegex = /(auto|scroll)/;\n    var properties = ['overflow', 'overflowX', 'overflowY'];\n    return properties.some(function (property) {\n      return overflowRegex.test(computedStyle[property]);\n    });\n  });\n}"]},"metadata":{},"sourceType":"module"}