{"ast":null,"code":"function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport { useRef, useCallback, useEffect } from 'react';\nimport getWidth from 'dom-lib/getWidth';\nimport getHeight from 'dom-lib/getHeight';\nimport getOffset from 'dom-lib/getOffset';\nimport { SCROLLBAR_WIDTH } from '../constants';\nimport { ResizeObserver } from '@juggle/resize-observer';\nimport useMount from './useMount';\nimport useUpdateLayoutEffect from './useUpdateLayoutEffect';\nimport isNumberOrTrue from './isNumberOrTrue';\n/**\n * The dimension information of the table,\n * including the height, width, scrollable distance and the coordinates of the scroll handle, etc.\n * @param props\n * @returns\n */\n\nvar useTableDimension = function useTableDimension(props) {\n  var data = props.data,\n      rowHeight = props.rowHeight,\n      tableRef = props.tableRef,\n      headerWrapperRef = props.headerWrapperRef,\n      prefix = props.prefix,\n      widthProp = props.width,\n      affixHeader = props.affixHeader,\n      affixHorizontalScrollbar = props.affixHorizontalScrollbar,\n      headerHeight = props.headerHeight,\n      height = props.height,\n      autoHeight = props.autoHeight,\n      children = props.children,\n      expandedRowKeys = props.expandedRowKeys,\n      onTableWidthChange = props.onTableWidthChange,\n      onTableContentWidthChange = props.onTableContentWidthChange,\n      onTableContentHeightChange = props.onTableContentHeightChange,\n      onTableScroll = props.onTableScroll;\n  var contentHeight = useRef(0);\n  var contentWidth = useRef(0);\n  var minScrollY = useRef(0);\n  var scrollY = useRef(0);\n  var scrollX = useRef(0);\n  var minScrollX = useRef(0);\n  var tableWidth = useRef(widthProp || 0);\n  var columnCount = useRef(0);\n  var resizeObserver = useRef();\n  var headerOffset = useRef(null);\n  var tableOffset = useRef(null);\n  var calculateTableContextHeight = useCallback(function () {\n    var prevContentHeight = contentHeight.current;\n    var table = tableRef === null || tableRef === void 0 ? void 0 : tableRef.current;\n    var rows = (table === null || table === void 0 ? void 0 : table.querySelectorAll(\".\" + (prefix === null || prefix === void 0 ? void 0 : prefix('row')))) || [];\n    var nextContentHeight = rows.length ? Array.from(rows).map(function (row) {\n      return getHeight(row) || rowHeight;\n    }).reduce(function (x, y) {\n      return x + y;\n    }) : 0; // After setting the affixHeader property, the height of the two headers should be subtracted.\n\n    contentHeight.current = Math.round(nextContentHeight - (affixHeader ? headerHeight * 2 : headerHeight));\n\n    if (!autoHeight) {\n      /**\n       *  The purpose of subtracting SCROLLBAR_WIDTH is to keep the scroll bar from blocking the content part.\n       *  But it will only be calculated when there is a horizontal scroll bar (contentWidth > tableWidth).\n       */\n      minScrollY.current = -(nextContentHeight - height) - (contentWidth.current > tableWidth.current ? SCROLLBAR_WIDTH : 0);\n    } // If the height of the content area is less than the height of the table, the vertical scroll bar is reset.\n\n\n    if (nextContentHeight < height) {\n      onTableScroll === null || onTableScroll === void 0 ? void 0 : onTableScroll({\n        y: 0\n      });\n    } // If the value of scrollTop is greater than the scrollable range, the vertical scroll bar is reset.\n    // When Table is set to virtualized, the logic will be entered every time the wheel event is triggered\n    // to avoid resetting the scroll bar after scrolling to the bottom, so add the SCROLLBAR_WIDTH value.\n\n\n    if (Math.abs(scrollY.current) + height - headerHeight > nextContentHeight + SCROLLBAR_WIDTH) {\n      onTableScroll === null || onTableScroll === void 0 ? void 0 : onTableScroll({\n        y: scrollY.current\n      });\n    }\n\n    if (prevContentHeight !== contentHeight.current) {\n      onTableContentHeightChange === null || onTableContentHeightChange === void 0 ? void 0 : onTableContentHeightChange(prevContentHeight);\n    }\n  }, [affixHeader, autoHeight, headerHeight, height, onTableScroll, onTableContentHeightChange, prefix, rowHeight, tableRef]);\n  var setOffsetByAffix = useCallback(function () {\n    var headerNode = headerWrapperRef === null || headerWrapperRef === void 0 ? void 0 : headerWrapperRef.current;\n\n    if (isNumberOrTrue(affixHeader) && headerNode) {\n      headerOffset.current = getOffset(headerNode);\n    }\n\n    if (isNumberOrTrue(affixHorizontalScrollbar) && tableRef !== null && tableRef !== void 0 && tableRef.current) {\n      tableOffset.current = getOffset(tableRef === null || tableRef === void 0 ? void 0 : tableRef.current);\n    }\n  }, [affixHeader, affixHorizontalScrollbar, headerWrapperRef, tableRef]);\n  var calculateTableContentWidth = useCallback(function () {\n    var prevWidth = contentWidth.current;\n    var prevColumnCount = columnCount.current;\n    var table = tableRef === null || tableRef === void 0 ? void 0 : tableRef.current;\n    var row = table === null || table === void 0 ? void 0 : table.querySelector(\".\" + prefix('row') + \":not(.virtualized)\");\n    var nextContentWidth = row ? getWidth(row) : 0;\n    contentWidth.current = nextContentWidth;\n    columnCount.current = (row === null || row === void 0 ? void 0 : row.querySelectorAll(\".\" + prefix('cell')).length) || 0; // The value of SCROLLBAR_WIDTH is subtracted so that the scroll bar does not block the content part.\n    // There is no vertical scroll bar after autoHeight.\n\n    minScrollX.current = -(nextContentWidth - tableWidth.current) - (autoHeight ? 0 : SCROLLBAR_WIDTH);\n    /**\n     * If the width of the content area and the number of columns change,\n     * the horizontal scroll bar is reset.\n     * fix: https://github.com/rsuite/rsuite/issues/2039\n     */\n\n    if (prevWidth > 0 && prevWidth !== contentWidth.current && prevColumnCount > 0 && prevColumnCount !== columnCount.current) {\n      onTableContentWidthChange === null || onTableContentWidthChange === void 0 ? void 0 : onTableContentWidthChange(prevWidth);\n    }\n  }, [autoHeight, onTableContentWidthChange, prefix, tableRef]);\n  var calculateTableWidth = useCallback(function (nextWidth) {\n    var prevWidth = tableWidth.current;\n\n    if (tableRef !== null && tableRef !== void 0 && tableRef.current) {\n      tableWidth.current = nextWidth || getWidth(tableRef === null || tableRef === void 0 ? void 0 : tableRef.current);\n    }\n\n    if (prevWidth && prevWidth !== tableWidth.current) {\n      scrollX.current = 0;\n      onTableWidthChange === null || onTableWidthChange === void 0 ? void 0 : onTableWidthChange(prevWidth);\n    }\n\n    setOffsetByAffix();\n  }, [onTableWidthChange, setOffsetByAffix, tableRef]);\n  useMount(function () {\n    calculateTableContextHeight();\n    calculateTableContentWidth();\n    calculateTableWidth();\n    setOffsetByAffix();\n    resizeObserver.current = new ResizeObserver(function (entries) {\n      for (var _iterator = _createForOfIteratorHelperLoose(entries), _step; !(_step = _iterator()).done;) {\n        var entry = _step.value;\n        calculateTableWidth(entry.contentRect.width);\n      }\n    });\n    resizeObserver.current.observe(tableRef === null || tableRef === void 0 ? void 0 : tableRef.current);\n  });\n  useUpdateLayoutEffect(function () {\n    calculateTableWidth();\n    calculateTableContextHeight();\n    calculateTableContentWidth();\n  }, [data, height, contentHeight, expandedRowKeys, children, calculateTableContextHeight, calculateTableContentWidth]);\n  useEffect(function () {\n    return function () {\n      var _resizeObserver$curre;\n\n      (_resizeObserver$curre = resizeObserver.current) === null || _resizeObserver$curre === void 0 ? void 0 : _resizeObserver$curre.disconnect();\n    };\n  }, []);\n  var setScrollY = useCallback(function (value) {\n    scrollY.current = value;\n  }, []);\n  var setScrollX = useCallback(function (value) {\n    scrollX.current = value;\n  }, []);\n  return {\n    contentHeight: contentHeight,\n    contentWidth: contentWidth,\n    minScrollY: minScrollY,\n    minScrollX: minScrollX,\n    scrollY: scrollY,\n    scrollX: scrollX,\n    tableWidth: tableWidth,\n    headerOffset: headerOffset,\n    tableOffset: tableOffset,\n    setScrollY: setScrollY,\n    setScrollX: setScrollX\n  };\n};\n\nexport default useTableDimension;","map":{"version":3,"sources":["/Users/supriyomal/Documents/GitHub/LeetQuestion/node_modules/rsuite-table/es/utils/useTableDimension.js"],"names":["_createForOfIteratorHelperLoose","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","i","done","value","TypeError","next","bind","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","from","test","arr","len","arr2","useRef","useCallback","useEffect","getWidth","getHeight","getOffset","SCROLLBAR_WIDTH","ResizeObserver","useMount","useUpdateLayoutEffect","isNumberOrTrue","useTableDimension","props","data","rowHeight","tableRef","headerWrapperRef","prefix","widthProp","width","affixHeader","affixHorizontalScrollbar","headerHeight","height","autoHeight","children","expandedRowKeys","onTableWidthChange","onTableContentWidthChange","onTableContentHeightChange","onTableScroll","contentHeight","contentWidth","minScrollY","scrollY","scrollX","minScrollX","tableWidth","columnCount","resizeObserver","headerOffset","tableOffset","calculateTableContextHeight","prevContentHeight","current","table","rows","querySelectorAll","nextContentHeight","map","row","reduce","x","y","Math","round","abs","setOffsetByAffix","headerNode","calculateTableContentWidth","prevWidth","prevColumnCount","querySelector","nextContentWidth","calculateTableWidth","nextWidth","entries","_iterator","_step","entry","contentRect","observe","_resizeObserver$curre","disconnect","setScrollY","setScrollX"],"mappings":"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","sourcesContent":["function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { useRef, useCallback, useEffect } from 'react';\nimport getWidth from 'dom-lib/getWidth';\nimport getHeight from 'dom-lib/getHeight';\nimport getOffset from 'dom-lib/getOffset';\nimport { SCROLLBAR_WIDTH } from '../constants';\nimport { ResizeObserver } from '@juggle/resize-observer';\nimport useMount from './useMount';\nimport useUpdateLayoutEffect from './useUpdateLayoutEffect';\nimport isNumberOrTrue from './isNumberOrTrue';\n\n/**\n * The dimension information of the table,\n * including the height, width, scrollable distance and the coordinates of the scroll handle, etc.\n * @param props\n * @returns\n */\nvar useTableDimension = function useTableDimension(props) {\n  var data = props.data,\n      rowHeight = props.rowHeight,\n      tableRef = props.tableRef,\n      headerWrapperRef = props.headerWrapperRef,\n      prefix = props.prefix,\n      widthProp = props.width,\n      affixHeader = props.affixHeader,\n      affixHorizontalScrollbar = props.affixHorizontalScrollbar,\n      headerHeight = props.headerHeight,\n      height = props.height,\n      autoHeight = props.autoHeight,\n      children = props.children,\n      expandedRowKeys = props.expandedRowKeys,\n      onTableWidthChange = props.onTableWidthChange,\n      onTableContentWidthChange = props.onTableContentWidthChange,\n      onTableContentHeightChange = props.onTableContentHeightChange,\n      onTableScroll = props.onTableScroll;\n  var contentHeight = useRef(0);\n  var contentWidth = useRef(0);\n  var minScrollY = useRef(0);\n  var scrollY = useRef(0);\n  var scrollX = useRef(0);\n  var minScrollX = useRef(0);\n  var tableWidth = useRef(widthProp || 0);\n  var columnCount = useRef(0);\n  var resizeObserver = useRef();\n  var headerOffset = useRef(null);\n  var tableOffset = useRef(null);\n  var calculateTableContextHeight = useCallback(function () {\n    var prevContentHeight = contentHeight.current;\n    var table = tableRef === null || tableRef === void 0 ? void 0 : tableRef.current;\n    var rows = (table === null || table === void 0 ? void 0 : table.querySelectorAll(\".\" + (prefix === null || prefix === void 0 ? void 0 : prefix('row')))) || [];\n    var nextContentHeight = rows.length ? Array.from(rows).map(function (row) {\n      return getHeight(row) || rowHeight;\n    }).reduce(function (x, y) {\n      return x + y;\n    }) : 0; // After setting the affixHeader property, the height of the two headers should be subtracted.\n\n    contentHeight.current = Math.round(nextContentHeight - (affixHeader ? headerHeight * 2 : headerHeight));\n\n    if (!autoHeight) {\n      /**\n       *  The purpose of subtracting SCROLLBAR_WIDTH is to keep the scroll bar from blocking the content part.\n       *  But it will only be calculated when there is a horizontal scroll bar (contentWidth > tableWidth).\n       */\n      minScrollY.current = -(nextContentHeight - height) - (contentWidth.current > tableWidth.current ? SCROLLBAR_WIDTH : 0);\n    } // If the height of the content area is less than the height of the table, the vertical scroll bar is reset.\n\n\n    if (nextContentHeight < height) {\n      onTableScroll === null || onTableScroll === void 0 ? void 0 : onTableScroll({\n        y: 0\n      });\n    } // If the value of scrollTop is greater than the scrollable range, the vertical scroll bar is reset.\n    // When Table is set to virtualized, the logic will be entered every time the wheel event is triggered\n    // to avoid resetting the scroll bar after scrolling to the bottom, so add the SCROLLBAR_WIDTH value.\n\n\n    if (Math.abs(scrollY.current) + height - headerHeight > nextContentHeight + SCROLLBAR_WIDTH) {\n      onTableScroll === null || onTableScroll === void 0 ? void 0 : onTableScroll({\n        y: scrollY.current\n      });\n    }\n\n    if (prevContentHeight !== contentHeight.current) {\n      onTableContentHeightChange === null || onTableContentHeightChange === void 0 ? void 0 : onTableContentHeightChange(prevContentHeight);\n    }\n  }, [affixHeader, autoHeight, headerHeight, height, onTableScroll, onTableContentHeightChange, prefix, rowHeight, tableRef]);\n  var setOffsetByAffix = useCallback(function () {\n    var headerNode = headerWrapperRef === null || headerWrapperRef === void 0 ? void 0 : headerWrapperRef.current;\n\n    if (isNumberOrTrue(affixHeader) && headerNode) {\n      headerOffset.current = getOffset(headerNode);\n    }\n\n    if (isNumberOrTrue(affixHorizontalScrollbar) && tableRef !== null && tableRef !== void 0 && tableRef.current) {\n      tableOffset.current = getOffset(tableRef === null || tableRef === void 0 ? void 0 : tableRef.current);\n    }\n  }, [affixHeader, affixHorizontalScrollbar, headerWrapperRef, tableRef]);\n  var calculateTableContentWidth = useCallback(function () {\n    var prevWidth = contentWidth.current;\n    var prevColumnCount = columnCount.current;\n    var table = tableRef === null || tableRef === void 0 ? void 0 : tableRef.current;\n    var row = table === null || table === void 0 ? void 0 : table.querySelector(\".\" + prefix('row') + \":not(.virtualized)\");\n    var nextContentWidth = row ? getWidth(row) : 0;\n    contentWidth.current = nextContentWidth;\n    columnCount.current = (row === null || row === void 0 ? void 0 : row.querySelectorAll(\".\" + prefix('cell')).length) || 0; // The value of SCROLLBAR_WIDTH is subtracted so that the scroll bar does not block the content part.\n    // There is no vertical scroll bar after autoHeight.\n\n    minScrollX.current = -(nextContentWidth - tableWidth.current) - (autoHeight ? 0 : SCROLLBAR_WIDTH);\n    /**\n     * If the width of the content area and the number of columns change,\n     * the horizontal scroll bar is reset.\n     * fix: https://github.com/rsuite/rsuite/issues/2039\n     */\n\n    if (prevWidth > 0 && prevWidth !== contentWidth.current && prevColumnCount > 0 && prevColumnCount !== columnCount.current) {\n      onTableContentWidthChange === null || onTableContentWidthChange === void 0 ? void 0 : onTableContentWidthChange(prevWidth);\n    }\n  }, [autoHeight, onTableContentWidthChange, prefix, tableRef]);\n  var calculateTableWidth = useCallback(function (nextWidth) {\n    var prevWidth = tableWidth.current;\n\n    if (tableRef !== null && tableRef !== void 0 && tableRef.current) {\n      tableWidth.current = nextWidth || getWidth(tableRef === null || tableRef === void 0 ? void 0 : tableRef.current);\n    }\n\n    if (prevWidth && prevWidth !== tableWidth.current) {\n      scrollX.current = 0;\n      onTableWidthChange === null || onTableWidthChange === void 0 ? void 0 : onTableWidthChange(prevWidth);\n    }\n\n    setOffsetByAffix();\n  }, [onTableWidthChange, setOffsetByAffix, tableRef]);\n  useMount(function () {\n    calculateTableContextHeight();\n    calculateTableContentWidth();\n    calculateTableWidth();\n    setOffsetByAffix();\n    resizeObserver.current = new ResizeObserver(function (entries) {\n      for (var _iterator = _createForOfIteratorHelperLoose(entries), _step; !(_step = _iterator()).done;) {\n        var entry = _step.value;\n        calculateTableWidth(entry.contentRect.width);\n      }\n    });\n    resizeObserver.current.observe(tableRef === null || tableRef === void 0 ? void 0 : tableRef.current);\n  });\n  useUpdateLayoutEffect(function () {\n    calculateTableWidth();\n    calculateTableContextHeight();\n    calculateTableContentWidth();\n  }, [data, height, contentHeight, expandedRowKeys, children, calculateTableContextHeight, calculateTableContentWidth]);\n  useEffect(function () {\n    return function () {\n      var _resizeObserver$curre;\n\n      (_resizeObserver$curre = resizeObserver.current) === null || _resizeObserver$curre === void 0 ? void 0 : _resizeObserver$curre.disconnect();\n    };\n  }, []);\n  var setScrollY = useCallback(function (value) {\n    scrollY.current = value;\n  }, []);\n  var setScrollX = useCallback(function (value) {\n    scrollX.current = value;\n  }, []);\n  return {\n    contentHeight: contentHeight,\n    contentWidth: contentWidth,\n    minScrollY: minScrollY,\n    minScrollX: minScrollX,\n    scrollY: scrollY,\n    scrollX: scrollX,\n    tableWidth: tableWidth,\n    headerOffset: headerOffset,\n    tableOffset: tableOffset,\n    setScrollY: setScrollY,\n    setScrollX: setScrollX\n  };\n};\n\nexport default useTableDimension;"]},"metadata":{},"sourceType":"module"}