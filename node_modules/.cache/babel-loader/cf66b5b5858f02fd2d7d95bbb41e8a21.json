{"ast":null,"code":"import maxBy from 'lodash/maxBy';\nimport minBy from 'lodash/minBy';\nimport kebabCase from 'lodash/kebabCase';\nimport ownerDocument from 'dom-lib/ownerDocument';\nimport getOffset from 'dom-lib/getOffset';\nimport scrollTop from 'dom-lib/scrollTop';\nimport scrollLeft from 'dom-lib/scrollLeft';\nimport _getPosition from 'dom-lib/getPosition';\nexport var AutoPlacement = {\n  left: 'Start',\n  right: 'End',\n  top: 'Start',\n  bottom: 'End'\n};\n/**\n * Get the external dimensions of the container\n * @param containerNode\n */\n\nfunction getContainerDimensions(containerNode) {\n  var width;\n  var height;\n  var scrollX;\n  var scrollY;\n\n  if (containerNode.tagName === 'BODY') {\n    width = window.innerWidth;\n    height = window.innerHeight;\n    scrollY = scrollTop(ownerDocument(containerNode).documentElement) || scrollTop(containerNode);\n    scrollX = scrollLeft(ownerDocument(containerNode).documentElement) || scrollLeft(containerNode);\n  } else {\n    var _ref = getOffset(containerNode);\n\n    width = _ref.width;\n    height = _ref.height;\n    scrollY = scrollTop(containerNode);\n    scrollX = scrollLeft(containerNode);\n  }\n\n  return {\n    width: width,\n    height: height,\n    scrollX: scrollX,\n    scrollY: scrollY\n  };\n}\n\nexport default (function (props) {\n  var placement = props.placement,\n      preventOverflow = props.preventOverflow,\n      padding = props.padding;\n\n  function getTopDelta(top, overlayHeight, container) {\n    if (!preventOverflow) {\n      return 0;\n    }\n\n    var containerDimensions = getContainerDimensions(container);\n    var containerHeight = containerDimensions.height,\n        scrollY = containerDimensions.scrollY;\n    var topEdgeOffset = top - padding - scrollY;\n    var bottomEdgeOffset = top + padding + overlayHeight - scrollY;\n\n    if (topEdgeOffset < 0) {\n      return -topEdgeOffset;\n    } else if (bottomEdgeOffset > containerHeight) {\n      return containerHeight - bottomEdgeOffset;\n    }\n\n    return 0;\n  }\n\n  function getLeftDelta(left, overlayWidth, container) {\n    if (!preventOverflow) {\n      return 0;\n    }\n\n    var containerDimensions = getContainerDimensions(container);\n    var scrollX = containerDimensions.scrollX,\n        containerWidth = containerDimensions.width;\n    var leftEdgeOffset = left - padding - scrollX;\n    var rightEdgeOffset = left + padding + overlayWidth - scrollX;\n\n    if (leftEdgeOffset < 0) {\n      return -leftEdgeOffset;\n    } else if (rightEdgeOffset > containerWidth) {\n      return containerWidth - rightEdgeOffset;\n    }\n\n    return 0;\n  }\n\n  function getPositionTop(container, overlayHeight, top) {\n    if (!preventOverflow) {\n      return top;\n    }\n\n    var _getContainerDimensio = getContainerDimensions(container),\n        scrollY = _getContainerDimensio.scrollY,\n        containerHeight = _getContainerDimensio.height; // 判断 overlay 底部是否溢出，设置 top\n\n\n    if (overlayHeight + top > containerHeight + scrollY) {\n      return containerHeight - overlayHeight + scrollY;\n    } // top 的最小值不能少于纵向滚动条 y 的值\n\n\n    return Math.max(scrollY, top);\n  }\n\n  function getPositionLeft(container, overlayWidth, left) {\n    if (!preventOverflow) {\n      return left;\n    }\n\n    var _getContainerDimensio2 = getContainerDimensions(container),\n        scrollX = _getContainerDimensio2.scrollX,\n        containerWidth = _getContainerDimensio2.width;\n\n    if (overlayWidth + left > containerWidth + scrollX) {\n      return containerWidth - overlayWidth + scrollX;\n    } // left 的最小值不能少于横向滚动条 x 的值\n\n\n    return Math.max(scrollX, left);\n  }\n\n  return {\n    getPosition: function getPosition(target, container) {\n      var offset = container.tagName === 'BODY' ? getOffset(target) : _getPosition(target, container, false);\n      return offset;\n    },\n    calcAutoPlacement: function calcAutoPlacement(targetOffset, container, overlay) {\n      var _getContainerDimensio3 = getContainerDimensions(container),\n          width = _getContainerDimensio3.width,\n          height = _getContainerDimensio3.height,\n          scrollX = _getContainerDimensio3.scrollX,\n          scrollY = _getContainerDimensio3.scrollY;\n\n      var left = targetOffset.left - scrollX - overlay.width;\n      var top = targetOffset.top - scrollY - overlay.height;\n      var right = width - targetOffset.left - targetOffset.width + scrollX - overlay.width;\n      var bottom = height - targetOffset.top - targetOffset.height + scrollY - overlay.height;\n      var horizontal = [{\n        key: 'left',\n        value: left\n      }, {\n        key: 'right',\n        value: right\n      }];\n      var vertical = [{\n        key: 'top',\n        value: top\n      }, {\n        key: 'bottom',\n        value: bottom\n      }];\n      var AV = 'autoVertical';\n      var AH = 'autoHorizontal';\n      var direction;\n      var align;\n\n      if (placement.indexOf(AV) !== -1) {\n        direction = maxBy(vertical, function (o) {\n          return o.value;\n        });\n        return placement === AV ? direction.key : \"\" + direction.key + placement.replace(AV, '');\n      } else if (placement.indexOf(AH) !== -1) {\n        direction = maxBy(horizontal, function (o) {\n          return o.value;\n        });\n        return placement === AH ? direction.key : \"\" + direction.key + placement.replace(AH, '');\n      }\n      /**\n       * Precedence Vertical\n       * [...vertical, ...horizontal]\n       */\n\n\n      direction = maxBy([].concat(vertical, horizontal), function (o) {\n        return o.value;\n      });\n\n      if (direction.key === 'left' || direction.key === 'right') {\n        align = minBy(vertical, function (o) {\n          return o.value;\n        });\n      } else {\n        align = minBy(horizontal, function (o) {\n          return o.value;\n        });\n      }\n\n      return \"\" + direction.key + AutoPlacement[align.key];\n    },\n    // Calculate the position of the overlay\n    calcOverlayPosition: function calcOverlayPosition(overlayNode, target, container) {\n      var childOffset = this.getPosition(target, container);\n\n      var _ref2 = getOffset(overlayNode),\n          overlayHeight = _ref2.height,\n          overlayWidth = _ref2.width;\n\n      var top = childOffset.top,\n          left = childOffset.left;\n      var nextPlacement = placement;\n\n      if (placement && placement.indexOf('auto') >= 0) {\n        nextPlacement = this.calcAutoPlacement(childOffset, container, {\n          height: overlayHeight,\n          width: overlayWidth\n        });\n      }\n\n      var positionLeft;\n      var positionTop;\n      var arrowOffsetLeft;\n      var arrowOffsetTop;\n\n      if (nextPlacement === 'left' || nextPlacement === 'right') {\n        positionTop = childOffset.top + (childOffset.height - overlayHeight) / 2;\n        var topDelta = getTopDelta(positionTop, overlayHeight, container);\n        positionTop += topDelta;\n        arrowOffsetTop = 50 * (1 - 2 * topDelta / overlayHeight) + \"%\";\n        arrowOffsetLeft = undefined;\n      } else if (nextPlacement === 'top' || nextPlacement === 'bottom') {\n        positionLeft = left + (childOffset.width - overlayWidth) / 2;\n        var leftDelta = getLeftDelta(positionLeft, overlayWidth, container);\n        positionLeft += leftDelta;\n        arrowOffsetLeft = 50 * (1 - 2 * leftDelta / overlayWidth) + \"%\";\n        arrowOffsetTop = undefined;\n      }\n\n      if (nextPlacement === 'top' || nextPlacement === 'topStart' || nextPlacement === 'topEnd') {\n        positionTop = getPositionTop(container, overlayHeight, childOffset.top - overlayHeight);\n      }\n\n      if (nextPlacement === 'bottom' || nextPlacement === 'bottomStart' || nextPlacement === 'bottomEnd') {\n        positionTop = getPositionTop(container, overlayHeight, childOffset.top + childOffset.height);\n      }\n\n      if (nextPlacement === 'left' || nextPlacement === 'leftStart' || nextPlacement === 'leftEnd') {\n        positionLeft = getPositionLeft(container, overlayWidth, childOffset.left - overlayWidth);\n      }\n\n      if (nextPlacement === 'right' || nextPlacement === 'rightStart' || nextPlacement === 'rightEnd') {\n        positionLeft = getPositionLeft(container, overlayWidth, childOffset.left + childOffset.width);\n      }\n\n      if (document.dir === 'rtl' && (nextPlacement === 'left' || nextPlacement === 'leftStart' || nextPlacement === 'leftEnd' || nextPlacement === 'right' || nextPlacement === 'rightStart' || nextPlacement === 'rightEnd')) {\n        /**\n         * When laying out in rtl, if the width of the container\n         * is less than the width of the container scrolling,\n         * you need to recalculate the left value.\n         */\n        var _getContainerDimensio4 = getContainerDimensions(container),\n            containerWidth = _getContainerDimensio4.width;\n\n        if (container.scrollWidth > containerWidth) {\n          positionLeft = containerWidth + positionLeft - container.scrollWidth;\n        }\n      }\n\n      if (nextPlacement === 'topStart' || nextPlacement === 'bottomStart') {\n        if (document.dir === 'rtl') {\n          var nextLeft = left + (childOffset.width - overlayWidth);\n          positionLeft = nextLeft + getLeftDelta(nextLeft, overlayWidth, container);\n        } else {\n          positionLeft = left + getLeftDelta(left, overlayWidth, container);\n        }\n      }\n\n      if (nextPlacement === 'topEnd' || nextPlacement === 'bottomEnd') {\n        if (document.dir === 'rtl') {\n          positionLeft = left + getLeftDelta(left, overlayWidth, container);\n        } else {\n          var _nextLeft = left + (childOffset.width - overlayWidth);\n\n          positionLeft = _nextLeft + getLeftDelta(_nextLeft, overlayWidth, container);\n        }\n      }\n\n      if (nextPlacement === 'leftStart' || nextPlacement === 'rightStart') {\n        positionTop = top + getTopDelta(top, overlayHeight, container);\n      }\n\n      if (nextPlacement === 'leftEnd' || nextPlacement === 'rightEnd') {\n        var nextTop = top + (childOffset.height - overlayHeight);\n        positionTop = nextTop + getTopDelta(nextTop, overlayHeight, container);\n      }\n\n      return {\n        positionLeft: positionLeft,\n        positionTop: positionTop,\n        arrowOffsetLeft: arrowOffsetLeft,\n        arrowOffsetTop: arrowOffsetTop,\n        positionClassName: \"placement-\" + kebabCase(nextPlacement)\n      };\n    }\n  };\n});","map":{"version":3,"sources":["/Users/supriyomal/Desktop/hekors-website-main/node_modules/rsuite/esm/Overlay/positionUtils.js"],"names":["maxBy","minBy","kebabCase","ownerDocument","getOffset","scrollTop","scrollLeft","_getPosition","AutoPlacement","left","right","top","bottom","getContainerDimensions","containerNode","width","height","scrollX","scrollY","tagName","window","innerWidth","innerHeight","documentElement","_ref","props","placement","preventOverflow","padding","getTopDelta","overlayHeight","container","containerDimensions","containerHeight","topEdgeOffset","bottomEdgeOffset","getLeftDelta","overlayWidth","containerWidth","leftEdgeOffset","rightEdgeOffset","getPositionTop","_getContainerDimensio","Math","max","getPositionLeft","_getContainerDimensio2","getPosition","target","offset","calcAutoPlacement","targetOffset","overlay","_getContainerDimensio3","horizontal","key","value","vertical","AV","AH","direction","align","indexOf","o","replace","concat","calcOverlayPosition","overlayNode","childOffset","_ref2","nextPlacement","positionLeft","positionTop","arrowOffsetLeft","arrowOffsetTop","topDelta","undefined","leftDelta","document","dir","_getContainerDimensio4","scrollWidth","nextLeft","_nextLeft","nextTop","positionClassName"],"mappings":"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","sourcesContent":["import maxBy from 'lodash/maxBy';\nimport minBy from 'lodash/minBy';\nimport kebabCase from 'lodash/kebabCase';\nimport ownerDocument from 'dom-lib/ownerDocument';\nimport getOffset from 'dom-lib/getOffset';\nimport scrollTop from 'dom-lib/scrollTop';\nimport scrollLeft from 'dom-lib/scrollLeft';\nimport _getPosition from 'dom-lib/getPosition';\nexport var AutoPlacement = {\n  left: 'Start',\n  right: 'End',\n  top: 'Start',\n  bottom: 'End'\n};\n\n/**\n * Get the external dimensions of the container\n * @param containerNode\n */\nfunction getContainerDimensions(containerNode) {\n  var width;\n  var height;\n  var scrollX;\n  var scrollY;\n\n  if (containerNode.tagName === 'BODY') {\n    width = window.innerWidth;\n    height = window.innerHeight;\n    scrollY = scrollTop(ownerDocument(containerNode).documentElement) || scrollTop(containerNode);\n    scrollX = scrollLeft(ownerDocument(containerNode).documentElement) || scrollLeft(containerNode);\n  } else {\n    var _ref = getOffset(containerNode);\n\n    width = _ref.width;\n    height = _ref.height;\n    scrollY = scrollTop(containerNode);\n    scrollX = scrollLeft(containerNode);\n  }\n\n  return {\n    width: width,\n    height: height,\n    scrollX: scrollX,\n    scrollY: scrollY\n  };\n}\n\nexport default (function (props) {\n  var placement = props.placement,\n      preventOverflow = props.preventOverflow,\n      padding = props.padding;\n\n  function getTopDelta(top, overlayHeight, container) {\n    if (!preventOverflow) {\n      return 0;\n    }\n\n    var containerDimensions = getContainerDimensions(container);\n    var containerHeight = containerDimensions.height,\n        scrollY = containerDimensions.scrollY;\n    var topEdgeOffset = top - padding - scrollY;\n    var bottomEdgeOffset = top + padding + overlayHeight - scrollY;\n\n    if (topEdgeOffset < 0) {\n      return -topEdgeOffset;\n    } else if (bottomEdgeOffset > containerHeight) {\n      return containerHeight - bottomEdgeOffset;\n    }\n\n    return 0;\n  }\n\n  function getLeftDelta(left, overlayWidth, container) {\n    if (!preventOverflow) {\n      return 0;\n    }\n\n    var containerDimensions = getContainerDimensions(container);\n    var scrollX = containerDimensions.scrollX,\n        containerWidth = containerDimensions.width;\n    var leftEdgeOffset = left - padding - scrollX;\n    var rightEdgeOffset = left + padding + overlayWidth - scrollX;\n\n    if (leftEdgeOffset < 0) {\n      return -leftEdgeOffset;\n    } else if (rightEdgeOffset > containerWidth) {\n      return containerWidth - rightEdgeOffset;\n    }\n\n    return 0;\n  }\n\n  function getPositionTop(container, overlayHeight, top) {\n    if (!preventOverflow) {\n      return top;\n    }\n\n    var _getContainerDimensio = getContainerDimensions(container),\n        scrollY = _getContainerDimensio.scrollY,\n        containerHeight = _getContainerDimensio.height; // 判断 overlay 底部是否溢出，设置 top\n\n\n    if (overlayHeight + top > containerHeight + scrollY) {\n      return containerHeight - overlayHeight + scrollY;\n    } // top 的最小值不能少于纵向滚动条 y 的值\n\n\n    return Math.max(scrollY, top);\n  }\n\n  function getPositionLeft(container, overlayWidth, left) {\n    if (!preventOverflow) {\n      return left;\n    }\n\n    var _getContainerDimensio2 = getContainerDimensions(container),\n        scrollX = _getContainerDimensio2.scrollX,\n        containerWidth = _getContainerDimensio2.width;\n\n    if (overlayWidth + left > containerWidth + scrollX) {\n      return containerWidth - overlayWidth + scrollX;\n    } // left 的最小值不能少于横向滚动条 x 的值\n\n\n    return Math.max(scrollX, left);\n  }\n\n  return {\n    getPosition: function getPosition(target, container) {\n      var offset = container.tagName === 'BODY' ? getOffset(target) : _getPosition(target, container, false);\n      return offset;\n    },\n    calcAutoPlacement: function calcAutoPlacement(targetOffset, container, overlay) {\n      var _getContainerDimensio3 = getContainerDimensions(container),\n          width = _getContainerDimensio3.width,\n          height = _getContainerDimensio3.height,\n          scrollX = _getContainerDimensio3.scrollX,\n          scrollY = _getContainerDimensio3.scrollY;\n\n      var left = targetOffset.left - scrollX - overlay.width;\n      var top = targetOffset.top - scrollY - overlay.height;\n      var right = width - targetOffset.left - targetOffset.width + scrollX - overlay.width;\n      var bottom = height - targetOffset.top - targetOffset.height + scrollY - overlay.height;\n      var horizontal = [{\n        key: 'left',\n        value: left\n      }, {\n        key: 'right',\n        value: right\n      }];\n      var vertical = [{\n        key: 'top',\n        value: top\n      }, {\n        key: 'bottom',\n        value: bottom\n      }];\n      var AV = 'autoVertical';\n      var AH = 'autoHorizontal';\n      var direction;\n      var align;\n\n      if (placement.indexOf(AV) !== -1) {\n        direction = maxBy(vertical, function (o) {\n          return o.value;\n        });\n        return placement === AV ? direction.key : \"\" + direction.key + placement.replace(AV, '');\n      } else if (placement.indexOf(AH) !== -1) {\n        direction = maxBy(horizontal, function (o) {\n          return o.value;\n        });\n        return placement === AH ? direction.key : \"\" + direction.key + placement.replace(AH, '');\n      }\n      /**\n       * Precedence Vertical\n       * [...vertical, ...horizontal]\n       */\n\n\n      direction = maxBy([].concat(vertical, horizontal), function (o) {\n        return o.value;\n      });\n\n      if (direction.key === 'left' || direction.key === 'right') {\n        align = minBy(vertical, function (o) {\n          return o.value;\n        });\n      } else {\n        align = minBy(horizontal, function (o) {\n          return o.value;\n        });\n      }\n\n      return \"\" + direction.key + AutoPlacement[align.key];\n    },\n    // Calculate the position of the overlay\n    calcOverlayPosition: function calcOverlayPosition(overlayNode, target, container) {\n      var childOffset = this.getPosition(target, container);\n\n      var _ref2 = getOffset(overlayNode),\n          overlayHeight = _ref2.height,\n          overlayWidth = _ref2.width;\n\n      var top = childOffset.top,\n          left = childOffset.left;\n      var nextPlacement = placement;\n\n      if (placement && placement.indexOf('auto') >= 0) {\n        nextPlacement = this.calcAutoPlacement(childOffset, container, {\n          height: overlayHeight,\n          width: overlayWidth\n        });\n      }\n\n      var positionLeft;\n      var positionTop;\n      var arrowOffsetLeft;\n      var arrowOffsetTop;\n\n      if (nextPlacement === 'left' || nextPlacement === 'right') {\n        positionTop = childOffset.top + (childOffset.height - overlayHeight) / 2;\n        var topDelta = getTopDelta(positionTop, overlayHeight, container);\n        positionTop += topDelta;\n        arrowOffsetTop = 50 * (1 - 2 * topDelta / overlayHeight) + \"%\";\n        arrowOffsetLeft = undefined;\n      } else if (nextPlacement === 'top' || nextPlacement === 'bottom') {\n        positionLeft = left + (childOffset.width - overlayWidth) / 2;\n        var leftDelta = getLeftDelta(positionLeft, overlayWidth, container);\n        positionLeft += leftDelta;\n        arrowOffsetLeft = 50 * (1 - 2 * leftDelta / overlayWidth) + \"%\";\n        arrowOffsetTop = undefined;\n      }\n\n      if (nextPlacement === 'top' || nextPlacement === 'topStart' || nextPlacement === 'topEnd') {\n        positionTop = getPositionTop(container, overlayHeight, childOffset.top - overlayHeight);\n      }\n\n      if (nextPlacement === 'bottom' || nextPlacement === 'bottomStart' || nextPlacement === 'bottomEnd') {\n        positionTop = getPositionTop(container, overlayHeight, childOffset.top + childOffset.height);\n      }\n\n      if (nextPlacement === 'left' || nextPlacement === 'leftStart' || nextPlacement === 'leftEnd') {\n        positionLeft = getPositionLeft(container, overlayWidth, childOffset.left - overlayWidth);\n      }\n\n      if (nextPlacement === 'right' || nextPlacement === 'rightStart' || nextPlacement === 'rightEnd') {\n        positionLeft = getPositionLeft(container, overlayWidth, childOffset.left + childOffset.width);\n      }\n\n      if (document.dir === 'rtl' && (nextPlacement === 'left' || nextPlacement === 'leftStart' || nextPlacement === 'leftEnd' || nextPlacement === 'right' || nextPlacement === 'rightStart' || nextPlacement === 'rightEnd')) {\n        /**\n         * When laying out in rtl, if the width of the container\n         * is less than the width of the container scrolling,\n         * you need to recalculate the left value.\n         */\n        var _getContainerDimensio4 = getContainerDimensions(container),\n            containerWidth = _getContainerDimensio4.width;\n\n        if (container.scrollWidth > containerWidth) {\n          positionLeft = containerWidth + positionLeft - container.scrollWidth;\n        }\n      }\n\n      if (nextPlacement === 'topStart' || nextPlacement === 'bottomStart') {\n        if (document.dir === 'rtl') {\n          var nextLeft = left + (childOffset.width - overlayWidth);\n          positionLeft = nextLeft + getLeftDelta(nextLeft, overlayWidth, container);\n        } else {\n          positionLeft = left + getLeftDelta(left, overlayWidth, container);\n        }\n      }\n\n      if (nextPlacement === 'topEnd' || nextPlacement === 'bottomEnd') {\n        if (document.dir === 'rtl') {\n          positionLeft = left + getLeftDelta(left, overlayWidth, container);\n        } else {\n          var _nextLeft = left + (childOffset.width - overlayWidth);\n\n          positionLeft = _nextLeft + getLeftDelta(_nextLeft, overlayWidth, container);\n        }\n      }\n\n      if (nextPlacement === 'leftStart' || nextPlacement === 'rightStart') {\n        positionTop = top + getTopDelta(top, overlayHeight, container);\n      }\n\n      if (nextPlacement === 'leftEnd' || nextPlacement === 'rightEnd') {\n        var nextTop = top + (childOffset.height - overlayHeight);\n        positionTop = nextTop + getTopDelta(nextTop, overlayHeight, container);\n      }\n\n      return {\n        positionLeft: positionLeft,\n        positionTop: positionTop,\n        arrowOffsetLeft: arrowOffsetLeft,\n        arrowOffsetTop: arrowOffsetTop,\n        positionClassName: \"placement-\" + kebabCase(nextPlacement)\n      };\n    }\n  };\n});"]},"metadata":{},"sourceType":"module"}