{"ast":null,"code":"import { convertMaskToPlaceholder, processCaretTraps, defaultPlaceholderChar } from './utilities';\nexport function isArray(value) {\n  return Array.isArray && Array.isArray(value) || value instanceof Array;\n}\nexport default function conformToMask(rawValue, mask, config) {\n  if (rawValue === void 0) {\n    rawValue = '';\n  }\n\n  if (mask === void 0) {\n    mask = [];\n  }\n\n  if (config === void 0) {\n    config = {};\n  }\n\n  if (!isArray(mask)) {\n    // If someone passes a function as the mask property, we should call the\n    // function to get the mask array - Normally this is handled by the\n    // `createTextMaskInputElement:update` function - this allows mask functions\n    // to be used directly with `conformToMask`\n    if (typeof mask === 'function') {\n      // call the mask function to get the mask array\n      mask = mask(rawValue, config); // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n      // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask\n\n      mask = processCaretTraps(mask).maskWithoutCaretTraps;\n    } else {\n      throw new Error('Text-mask:conformToMask; The mask property must be an array.');\n    }\n  } // These configurations tell us how to conform the mask\n\n\n  var _config = config,\n      _config$guide = _config.guide,\n      guide = _config$guide === void 0 ? true : _config$guide,\n      _config$previousConfo = _config.previousConformedValue,\n      previousConformedValue = _config$previousConfo === void 0 ? '' : _config$previousConfo,\n      _config$placeholderCh = _config.placeholderChar,\n      placeholderChar = _config$placeholderCh === void 0 ? defaultPlaceholderChar : _config$placeholderCh,\n      _config$placeholder = _config.placeholder,\n      placeholder = _config$placeholder === void 0 ? convertMaskToPlaceholder(mask, placeholderChar) : _config$placeholder,\n      _config$currentCaretP = _config.currentCaretPosition,\n      currentCaretPosition = _config$currentCaretP === void 0 ? 0 : _config$currentCaretP,\n      keepCharPositions = _config.keepCharPositions; // The configs below indicate that the user wants the algorithm to work in *no guide* mode\n\n  var suppressGuide = guide === false && previousConformedValue !== undefined; // Calculate lengths once for performance\n\n  var rawValueLength = rawValue.length;\n  var previousConformedValueLength = previousConformedValue.length;\n  var placeholderLength = placeholder.length;\n  var maskLength = mask.length; // This tells us the number of edited characters and the direction in which they were edited (+/-)\n\n  var editDistance = rawValueLength - previousConformedValueLength; // In *no guide* mode, we need to know if the user is trying to add a character or not\n\n  var isAddition = editDistance > 0; // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1\n\n  var indexOfFirstChange = currentCaretPosition + (isAddition ? -editDistance : 0); // We're also gonna need the index of last change, which we can derive as follows...\n\n  var indexOfLastChange = indexOfFirstChange + Math.abs(editDistance); // If `conformToMask` is configured to keep character positions, that is, for mask 111, previous value\n  // _2_ and raw value 3_2_, the new conformed value should be 32_, not 3_2 (default behavior). That's in the case of\n  // addition. And in the case of deletion, previous value _23, raw value _3, the new conformed string should be\n  // __3, not _3_ (default behavior)\n  //\n  // The next block of logic handles keeping character positions for the case of deletion. (Keeping\n  // character positions for the case of addition is further down since it is handled differently.)\n  // To do this, we want to compensate for all characters that were deleted\n\n  if (keepCharPositions === true && !isAddition) {\n    // We will be storing the new placeholder characters in this variable.\n    var compensatingPlaceholderChars = ''; // For every character that was deleted from a placeholder position, we add a placeholder char\n\n    for (var i = indexOfFirstChange; i < indexOfLastChange; i++) {\n      if (placeholder[i] === placeholderChar) {\n        compensatingPlaceholderChars += placeholderChar;\n      }\n    } // Now we trick our algorithm by modifying the raw value to make it contain additional placeholder characters\n    // That way when the we start laying the characters again on the mask, it will keep the non-deleted characters\n    // in their positions.\n\n\n    rawValue = rawValue.slice(0, indexOfFirstChange) + compensatingPlaceholderChars + rawValue.slice(indexOfFirstChange, rawValueLength);\n  } // Convert `rawValue` string to an array, and mark characters based on whether they are newly added or have\n  // existed in the previous conformed value. Identifying new and old characters is needed for `conformToMask`\n  // to work if it is configured to keep character positions.\n\n\n  var rawValueArr = rawValue.split('').map(function (char, i) {\n    return {\n      char: char,\n      isNew: i >= indexOfFirstChange && i < indexOfLastChange\n    };\n  }); // The loop below removes masking characters from user input. For example, for mask\n  // `00 (111)`, the placeholder would be `00 (___)`. If user input is `00 (234)`, the loop below\n  // would remove all characters but `234` from the `rawValueArr`. The rest of the algorithm\n  // then would lay `234` on top of the available placeholder positions in the mask.\n\n  for (var _i = rawValueLength - 1; _i >= 0; _i--) {\n    var char = rawValueArr[_i].char;\n\n    if (char !== placeholderChar) {\n      var shouldOffset = _i >= indexOfFirstChange && previousConformedValueLength === maskLength;\n\n      if (char === placeholder[shouldOffset ? _i - editDistance : _i]) {\n        rawValueArr.splice(_i, 1);\n      }\n    }\n  } // This is the variable that we will be filling with characters as we figure them out\n  // in the algorithm below\n\n\n  var conformedValue = '';\n  var someCharsRejected = false; // Ok, so first we loop through the placeholder looking for placeholder characters to fill up.\n\n  placeholderLoop: for (var _i2 = 0; _i2 < placeholderLength; _i2++) {\n    var charInPlaceholder = placeholder[_i2]; // We see one. Let's find out what we can put in it.\n\n    if (charInPlaceholder === placeholderChar) {\n      // But before that, do we actually have any user characters that need a place?\n      if (rawValueArr.length > 0) {\n        // We will keep chipping away at user input until either we run out of characters\n        // or we find at least one character that we can map.\n        while (rawValueArr.length > 0) {\n          // Let's retrieve the first user character in the queue of characters we have left\n          var _ref = rawValueArr.shift(),\n              rawValueChar = _ref.char,\n              isNew = _ref.isNew; // If the character we got from the user input is a placeholder character (which happens\n          // regularly because user input could be something like (540) 90_-____, which includes\n          // a bunch of `_` which are placeholder characters) and we are not in *no guide* mode,\n          // then we map this placeholder character to the current spot in the placeholder\n\n\n          if (rawValueChar === placeholderChar && suppressGuide !== true) {\n            conformedValue += placeholderChar; // And we go to find the next placeholder character that needs filling\n\n            continue placeholderLoop; // Else if, the character we got from the user input is not a placeholder, let's see\n            // if the current position in the mask can accept it.\n          } else if (mask[_i2].test(rawValueChar)) {\n            // we map the character differently based on whether we are keeping character positions or not.\n            // If any of the conditions below are met, we simply map the raw value character to the\n            // placeholder position.\n            if (keepCharPositions !== true || isNew === false || previousConformedValue === '' || guide === false || !isAddition) {\n              conformedValue += rawValueChar;\n            } else {\n              // We enter this block of code if we are trying to keep character positions and none of the conditions\n              // above is met. In this case, we need to see if there's an available spot for the raw value character\n              // to be mapped to. If we couldn't find a spot, we will discard the character.\n              //\n              // For example, for mask `1111`, previous conformed value `_2__`, raw value `942_2__`. We can map the\n              // `9`, to the first available placeholder position, but then, there are no more spots available for the\n              // `4` and `2`. So, we discard them and end up with a conformed value of `92__`.\n              var rawValueArrLength = rawValueArr.length;\n              var indexOfNextAvailablePlaceholderChar = null; // Let's loop through the remaining raw value characters. We are looking for either a suitable spot, ie,\n              // a placeholder character or a non-suitable spot, ie, a non-placeholder character that is not new.\n              // If we see a suitable spot first, we store its position and exit the loop. If we see a non-suitable\n              // spot first, we exit the loop and our `indexOfNextAvailablePlaceholderChar` will stay as `null`.\n\n              for (var _i3 = 0; _i3 < rawValueArrLength; _i3++) {\n                var charData = rawValueArr[_i3];\n\n                if (charData.char !== placeholderChar && charData.isNew === false) {\n                  break;\n                }\n\n                if (charData.char === placeholderChar) {\n                  indexOfNextAvailablePlaceholderChar = _i3;\n                  break;\n                }\n              } // If `indexOfNextAvailablePlaceholderChar` is not `null`, that means the character is not blocked.\n              // We can map it. And to keep the character positions, we remove the placeholder character\n              // from the remaining characters\n\n\n              if (indexOfNextAvailablePlaceholderChar !== null) {\n                conformedValue += rawValueChar;\n                rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1); // If `indexOfNextAvailablePlaceholderChar` is `null`, that means the character is blocked. We have to\n                // discard it.\n              } else {\n                _i2--;\n              }\n            } // Since we've mapped this placeholder position. We move on to the next one.\n\n\n            continue placeholderLoop;\n          } else {\n            someCharsRejected = true;\n          }\n        }\n      } // We reach this point when we've mapped all the user input characters to placeholder\n      // positions in the mask. In *guide* mode, we append the left over characters in the\n      // placeholder to the `conformedString`, but in *no guide* mode, we don't wanna do that.\n      //\n      // That is, for mask `(111)` and user input `2`, we want to return `(2`, not `(2__)`.\n\n\n      if (suppressGuide === false) {\n        conformedValue += placeholder.substr(_i2, placeholderLength);\n      } // And we break\n\n\n      break; // Else, the charInPlaceholder is not a placeholderChar. That is, we cannot fill it\n      // with user input. So we just map it to the final output\n    } else {\n      conformedValue += charInPlaceholder;\n    }\n  } // The following logic is needed to deal with the case of deletion in *no guide* mode.\n  //\n  // Consider the silly mask `(111) /// 1`. What if user tries to delete the last placeholder\n  // position? Something like `(589) /// `. We want to conform that to `(589`. Not `(589) /// `.\n  // That's why the logic below finds the last filled placeholder character, and removes everything\n  // from that point on.\n\n\n  if (suppressGuide && isAddition === false) {\n    var indexOfLastFilledPlaceholderChar = null; // Find the last filled placeholder position and substring from there\n\n    for (var _i4 = 0; _i4 < conformedValue.length; _i4++) {\n      if (placeholder[_i4] === placeholderChar) {\n        indexOfLastFilledPlaceholderChar = _i4;\n      }\n    }\n\n    if (indexOfLastFilledPlaceholderChar !== null) {\n      // We substring from the beginning until the position after the last filled placeholder char.\n      conformedValue = conformedValue.substr(0, indexOfLastFilledPlaceholderChar + 1);\n    } else {\n      // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted\n      // the first character in the mask. So we return an empty string.\n      conformedValue = '';\n    }\n  }\n\n  return {\n    conformedValue: conformedValue,\n    meta: {\n      someCharsRejected: someCharsRejected\n    }\n  };\n}","map":{"version":3,"sources":["/Users/supriyomal/Documents/GitHub/LeetQuestion/node_modules/rsuite/esm/MaskedInput/conformToMask.js"],"names":["convertMaskToPlaceholder","processCaretTraps","defaultPlaceholderChar","isArray","value","Array","conformToMask","rawValue","mask","config","maskWithoutCaretTraps","Error","_config","_config$guide","guide","_config$previousConfo","previousConformedValue","_config$placeholderCh","placeholderChar","_config$placeholder","placeholder","_config$currentCaretP","currentCaretPosition","keepCharPositions","suppressGuide","undefined","rawValueLength","length","previousConformedValueLength","placeholderLength","maskLength","editDistance","isAddition","indexOfFirstChange","indexOfLastChange","Math","abs","compensatingPlaceholderChars","i","slice","rawValueArr","split","map","char","isNew","_i","shouldOffset","splice","conformedValue","someCharsRejected","placeholderLoop","_i2","charInPlaceholder","_ref","shift","rawValueChar","test","rawValueArrLength","indexOfNextAvailablePlaceholderChar","_i3","charData","substr","indexOfLastFilledPlaceholderChar","_i4","meta"],"mappings":"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","sourcesContent":["import { convertMaskToPlaceholder, processCaretTraps, defaultPlaceholderChar } from './utilities';\nexport function isArray(value) {\n  return Array.isArray && Array.isArray(value) || value instanceof Array;\n}\nexport default function conformToMask(rawValue, mask, config) {\n  if (rawValue === void 0) {\n    rawValue = '';\n  }\n\n  if (mask === void 0) {\n    mask = [];\n  }\n\n  if (config === void 0) {\n    config = {};\n  }\n\n  if (!isArray(mask)) {\n    // If someone passes a function as the mask property, we should call the\n    // function to get the mask array - Normally this is handled by the\n    // `createTextMaskInputElement:update` function - this allows mask functions\n    // to be used directly with `conformToMask`\n    if (typeof mask === 'function') {\n      // call the mask function to get the mask array\n      mask = mask(rawValue, config); // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n      // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask\n\n      mask = processCaretTraps(mask).maskWithoutCaretTraps;\n    } else {\n      throw new Error('Text-mask:conformToMask; The mask property must be an array.');\n    }\n  } // These configurations tell us how to conform the mask\n\n\n  var _config = config,\n      _config$guide = _config.guide,\n      guide = _config$guide === void 0 ? true : _config$guide,\n      _config$previousConfo = _config.previousConformedValue,\n      previousConformedValue = _config$previousConfo === void 0 ? '' : _config$previousConfo,\n      _config$placeholderCh = _config.placeholderChar,\n      placeholderChar = _config$placeholderCh === void 0 ? defaultPlaceholderChar : _config$placeholderCh,\n      _config$placeholder = _config.placeholder,\n      placeholder = _config$placeholder === void 0 ? convertMaskToPlaceholder(mask, placeholderChar) : _config$placeholder,\n      _config$currentCaretP = _config.currentCaretPosition,\n      currentCaretPosition = _config$currentCaretP === void 0 ? 0 : _config$currentCaretP,\n      keepCharPositions = _config.keepCharPositions; // The configs below indicate that the user wants the algorithm to work in *no guide* mode\n\n  var suppressGuide = guide === false && previousConformedValue !== undefined; // Calculate lengths once for performance\n\n  var rawValueLength = rawValue.length;\n  var previousConformedValueLength = previousConformedValue.length;\n  var placeholderLength = placeholder.length;\n  var maskLength = mask.length; // This tells us the number of edited characters and the direction in which they were edited (+/-)\n\n  var editDistance = rawValueLength - previousConformedValueLength; // In *no guide* mode, we need to know if the user is trying to add a character or not\n\n  var isAddition = editDistance > 0; // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1\n\n  var indexOfFirstChange = currentCaretPosition + (isAddition ? -editDistance : 0); // We're also gonna need the index of last change, which we can derive as follows...\n\n  var indexOfLastChange = indexOfFirstChange + Math.abs(editDistance); // If `conformToMask` is configured to keep character positions, that is, for mask 111, previous value\n  // _2_ and raw value 3_2_, the new conformed value should be 32_, not 3_2 (default behavior). That's in the case of\n  // addition. And in the case of deletion, previous value _23, raw value _3, the new conformed string should be\n  // __3, not _3_ (default behavior)\n  //\n  // The next block of logic handles keeping character positions for the case of deletion. (Keeping\n  // character positions for the case of addition is further down since it is handled differently.)\n  // To do this, we want to compensate for all characters that were deleted\n\n  if (keepCharPositions === true && !isAddition) {\n    // We will be storing the new placeholder characters in this variable.\n    var compensatingPlaceholderChars = ''; // For every character that was deleted from a placeholder position, we add a placeholder char\n\n    for (var i = indexOfFirstChange; i < indexOfLastChange; i++) {\n      if (placeholder[i] === placeholderChar) {\n        compensatingPlaceholderChars += placeholderChar;\n      }\n    } // Now we trick our algorithm by modifying the raw value to make it contain additional placeholder characters\n    // That way when the we start laying the characters again on the mask, it will keep the non-deleted characters\n    // in their positions.\n\n\n    rawValue = rawValue.slice(0, indexOfFirstChange) + compensatingPlaceholderChars + rawValue.slice(indexOfFirstChange, rawValueLength);\n  } // Convert `rawValue` string to an array, and mark characters based on whether they are newly added or have\n  // existed in the previous conformed value. Identifying new and old characters is needed for `conformToMask`\n  // to work if it is configured to keep character positions.\n\n\n  var rawValueArr = rawValue.split('').map(function (char, i) {\n    return {\n      char: char,\n      isNew: i >= indexOfFirstChange && i < indexOfLastChange\n    };\n  }); // The loop below removes masking characters from user input. For example, for mask\n  // `00 (111)`, the placeholder would be `00 (___)`. If user input is `00 (234)`, the loop below\n  // would remove all characters but `234` from the `rawValueArr`. The rest of the algorithm\n  // then would lay `234` on top of the available placeholder positions in the mask.\n\n  for (var _i = rawValueLength - 1; _i >= 0; _i--) {\n    var char = rawValueArr[_i].char;\n\n    if (char !== placeholderChar) {\n      var shouldOffset = _i >= indexOfFirstChange && previousConformedValueLength === maskLength;\n\n      if (char === placeholder[shouldOffset ? _i - editDistance : _i]) {\n        rawValueArr.splice(_i, 1);\n      }\n    }\n  } // This is the variable that we will be filling with characters as we figure them out\n  // in the algorithm below\n\n\n  var conformedValue = '';\n  var someCharsRejected = false; // Ok, so first we loop through the placeholder looking for placeholder characters to fill up.\n\n  placeholderLoop: for (var _i2 = 0; _i2 < placeholderLength; _i2++) {\n    var charInPlaceholder = placeholder[_i2]; // We see one. Let's find out what we can put in it.\n\n    if (charInPlaceholder === placeholderChar) {\n      // But before that, do we actually have any user characters that need a place?\n      if (rawValueArr.length > 0) {\n        // We will keep chipping away at user input until either we run out of characters\n        // or we find at least one character that we can map.\n        while (rawValueArr.length > 0) {\n          // Let's retrieve the first user character in the queue of characters we have left\n          var _ref = rawValueArr.shift(),\n              rawValueChar = _ref.char,\n              isNew = _ref.isNew; // If the character we got from the user input is a placeholder character (which happens\n          // regularly because user input could be something like (540) 90_-____, which includes\n          // a bunch of `_` which are placeholder characters) and we are not in *no guide* mode,\n          // then we map this placeholder character to the current spot in the placeholder\n\n\n          if (rawValueChar === placeholderChar && suppressGuide !== true) {\n            conformedValue += placeholderChar; // And we go to find the next placeholder character that needs filling\n\n            continue placeholderLoop; // Else if, the character we got from the user input is not a placeholder, let's see\n            // if the current position in the mask can accept it.\n          } else if (mask[_i2].test(rawValueChar)) {\n            // we map the character differently based on whether we are keeping character positions or not.\n            // If any of the conditions below are met, we simply map the raw value character to the\n            // placeholder position.\n            if (keepCharPositions !== true || isNew === false || previousConformedValue === '' || guide === false || !isAddition) {\n              conformedValue += rawValueChar;\n            } else {\n              // We enter this block of code if we are trying to keep character positions and none of the conditions\n              // above is met. In this case, we need to see if there's an available spot for the raw value character\n              // to be mapped to. If we couldn't find a spot, we will discard the character.\n              //\n              // For example, for mask `1111`, previous conformed value `_2__`, raw value `942_2__`. We can map the\n              // `9`, to the first available placeholder position, but then, there are no more spots available for the\n              // `4` and `2`. So, we discard them and end up with a conformed value of `92__`.\n              var rawValueArrLength = rawValueArr.length;\n              var indexOfNextAvailablePlaceholderChar = null; // Let's loop through the remaining raw value characters. We are looking for either a suitable spot, ie,\n              // a placeholder character or a non-suitable spot, ie, a non-placeholder character that is not new.\n              // If we see a suitable spot first, we store its position and exit the loop. If we see a non-suitable\n              // spot first, we exit the loop and our `indexOfNextAvailablePlaceholderChar` will stay as `null`.\n\n              for (var _i3 = 0; _i3 < rawValueArrLength; _i3++) {\n                var charData = rawValueArr[_i3];\n\n                if (charData.char !== placeholderChar && charData.isNew === false) {\n                  break;\n                }\n\n                if (charData.char === placeholderChar) {\n                  indexOfNextAvailablePlaceholderChar = _i3;\n                  break;\n                }\n              } // If `indexOfNextAvailablePlaceholderChar` is not `null`, that means the character is not blocked.\n              // We can map it. And to keep the character positions, we remove the placeholder character\n              // from the remaining characters\n\n\n              if (indexOfNextAvailablePlaceholderChar !== null) {\n                conformedValue += rawValueChar;\n                rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1); // If `indexOfNextAvailablePlaceholderChar` is `null`, that means the character is blocked. We have to\n                // discard it.\n              } else {\n                _i2--;\n              }\n            } // Since we've mapped this placeholder position. We move on to the next one.\n\n\n            continue placeholderLoop;\n          } else {\n            someCharsRejected = true;\n          }\n        }\n      } // We reach this point when we've mapped all the user input characters to placeholder\n      // positions in the mask. In *guide* mode, we append the left over characters in the\n      // placeholder to the `conformedString`, but in *no guide* mode, we don't wanna do that.\n      //\n      // That is, for mask `(111)` and user input `2`, we want to return `(2`, not `(2__)`.\n\n\n      if (suppressGuide === false) {\n        conformedValue += placeholder.substr(_i2, placeholderLength);\n      } // And we break\n\n\n      break; // Else, the charInPlaceholder is not a placeholderChar. That is, we cannot fill it\n      // with user input. So we just map it to the final output\n    } else {\n      conformedValue += charInPlaceholder;\n    }\n  } // The following logic is needed to deal with the case of deletion in *no guide* mode.\n  //\n  // Consider the silly mask `(111) /// 1`. What if user tries to delete the last placeholder\n  // position? Something like `(589) /// `. We want to conform that to `(589`. Not `(589) /// `.\n  // That's why the logic below finds the last filled placeholder character, and removes everything\n  // from that point on.\n\n\n  if (suppressGuide && isAddition === false) {\n    var indexOfLastFilledPlaceholderChar = null; // Find the last filled placeholder position and substring from there\n\n    for (var _i4 = 0; _i4 < conformedValue.length; _i4++) {\n      if (placeholder[_i4] === placeholderChar) {\n        indexOfLastFilledPlaceholderChar = _i4;\n      }\n    }\n\n    if (indexOfLastFilledPlaceholderChar !== null) {\n      // We substring from the beginning until the position after the last filled placeholder char.\n      conformedValue = conformedValue.substr(0, indexOfLastFilledPlaceholderChar + 1);\n    } else {\n      // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted\n      // the first character in the mask. So we return an empty string.\n      conformedValue = '';\n    }\n  }\n\n  return {\n    conformedValue: conformedValue,\n    meta: {\n      someCharsRejected: someCharsRejected\n    }\n  };\n}"]},"metadata":{},"sourceType":"module"}