"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports["default"] = void 0;

var _react = require("react");

var _getWidth = _interopRequireDefault(require("dom-lib/getWidth"));

var _getHeight = _interopRequireDefault(require("dom-lib/getHeight"));

var _getOffset = _interopRequireDefault(require("dom-lib/getOffset"));

var _constants = require("../constants");

var _resizeObserver = require("@juggle/resize-observer");

var _useMount = _interopRequireDefault(require("./useMount"));

var _useUpdateLayoutEffect = _interopRequireDefault(require("./useUpdateLayoutEffect"));

var _isNumberOrTrue = _interopRequireDefault(require("./isNumberOrTrue"));

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * The dimension information of the table,
 * including the height, width, scrollable distance and the coordinates of the scroll handle, etc.
 * @param props
 * @returns
 */
var useTableDimension = function useTableDimension(props) {
  var data = props.data,
      rowHeight = props.rowHeight,
      tableRef = props.tableRef,
      headerWrapperRef = props.headerWrapperRef,
      prefix = props.prefix,
      widthProp = props.width,
      affixHeader = props.affixHeader,
      affixHorizontalScrollbar = props.affixHorizontalScrollbar,
      headerHeight = props.headerHeight,
      height = props.height,
      autoHeight = props.autoHeight,
      children = props.children,
      expandedRowKeys = props.expandedRowKeys,
      onTableWidthChange = props.onTableWidthChange,
      onTableContentWidthChange = props.onTableContentWidthChange,
      onTableContentHeightChange = props.onTableContentHeightChange,
      onTableScroll = props.onTableScroll;
  var contentHeight = (0, _react.useRef)(0);
  var contentWidth = (0, _react.useRef)(0);
  var minScrollY = (0, _react.useRef)(0);
  var scrollY = (0, _react.useRef)(0);
  var scrollX = (0, _react.useRef)(0);
  var minScrollX = (0, _react.useRef)(0);
  var tableWidth = (0, _react.useRef)(widthProp || 0);
  var columnCount = (0, _react.useRef)(0);
  var resizeObserver = (0, _react.useRef)();
  var headerOffset = (0, _react.useRef)(null);
  var tableOffset = (0, _react.useRef)(null);
  var calculateTableContextHeight = (0, _react.useCallback)(function () {
    var prevContentHeight = contentHeight.current;
    var table = tableRef === null || tableRef === void 0 ? void 0 : tableRef.current;
    var rows = (table === null || table === void 0 ? void 0 : table.querySelectorAll("." + (prefix === null || prefix === void 0 ? void 0 : prefix('row')))) || [];
    var nextContentHeight = rows.length ? Array.from(rows).map(function (row) {
      return (0, _getHeight["default"])(row) || rowHeight;
    }).reduce(function (x, y) {
      return x + y;
    }) : 0; // After setting the affixHeader property, the height of the two headers should be subtracted.

    contentHeight.current = Math.round(nextContentHeight - (affixHeader ? headerHeight * 2 : headerHeight));

    if (!autoHeight) {
      /**
       *  The purpose of subtracting SCROLLBAR_WIDTH is to keep the scroll bar from blocking the content part.
       *  But it will only be calculated when there is a horizontal scroll bar (contentWidth > tableWidth).
       */
      minScrollY.current = -(nextContentHeight - height) - (contentWidth.current > tableWidth.current ? _constants.SCROLLBAR_WIDTH : 0);
    } // If the height of the content area is less than the height of the table, the vertical scroll bar is reset.


    if (nextContentHeight < height) {
      onTableScroll === null || onTableScroll === void 0 ? void 0 : onTableScroll({
        y: 0
      });
    } // If the value of scrollTop is greater than the scrollable range, the vertical scroll bar is reset.
    // When Table is set to virtualized, the logic will be entered every time the wheel event is triggered
    // to avoid resetting the scroll bar after scrolling to the bottom, so add the SCROLLBAR_WIDTH value.


    if (Math.abs(scrollY.current) + height - headerHeight > nextContentHeight + _constants.SCROLLBAR_WIDTH) {
      onTableScroll === null || onTableScroll === void 0 ? void 0 : onTableScroll({
        y: scrollY.current
      });
    }

    if (prevContentHeight !== contentHeight.current) {
      onTableContentHeightChange === null || onTableContentHeightChange === void 0 ? void 0 : onTableContentHeightChange(prevContentHeight);
    }
  }, [affixHeader, autoHeight, headerHeight, height, onTableScroll, onTableContentHeightChange, prefix, rowHeight, tableRef]);
  var setOffsetByAffix = (0, _react.useCallback)(function () {
    var headerNode = headerWrapperRef === null || headerWrapperRef === void 0 ? void 0 : headerWrapperRef.current;

    if ((0, _isNumberOrTrue["default"])(affixHeader) && headerNode) {
      headerOffset.current = (0, _getOffset["default"])(headerNode);
    }

    if ((0, _isNumberOrTrue["default"])(affixHorizontalScrollbar) && tableRef !== null && tableRef !== void 0 && tableRef.current) {
      tableOffset.current = (0, _getOffset["default"])(tableRef === null || tableRef === void 0 ? void 0 : tableRef.current);
    }
  }, [affixHeader, affixHorizontalScrollbar, headerWrapperRef, tableRef]);
  var calculateTableContentWidth = (0, _react.useCallback)(function () {
    var prevWidth = contentWidth.current;
    var prevColumnCount = columnCount.current;
    var table = tableRef === null || tableRef === void 0 ? void 0 : tableRef.current;
    var row = table === null || table === void 0 ? void 0 : table.querySelector("." + prefix('row') + ":not(.virtualized)");
    var nextContentWidth = row ? (0, _getWidth["default"])(row) : 0;
    contentWidth.current = nextContentWidth;
    columnCount.current = (row === null || row === void 0 ? void 0 : row.querySelectorAll("." + prefix('cell')).length) || 0; // The value of SCROLLBAR_WIDTH is subtracted so that the scroll bar does not block the content part.
    // There is no vertical scroll bar after autoHeight.

    minScrollX.current = -(nextContentWidth - tableWidth.current) - (autoHeight ? 0 : _constants.SCROLLBAR_WIDTH);
    /**
     * If the width of the content area and the number of columns change,
     * the horizontal scroll bar is reset.
     * fix: https://github.com/rsuite/rsuite/issues/2039
     */

    if (prevWidth > 0 && prevWidth !== contentWidth.current && prevColumnCount > 0 && prevColumnCount !== columnCount.current) {
      onTableContentWidthChange === null || onTableContentWidthChange === void 0 ? void 0 : onTableContentWidthChange(prevWidth);
    }
  }, [autoHeight, onTableContentWidthChange, prefix, tableRef]);
  var calculateTableWidth = (0, _react.useCallback)(function (nextWidth) {
    var prevWidth = tableWidth.current;

    if (tableRef !== null && tableRef !== void 0 && tableRef.current) {
      tableWidth.current = nextWidth || (0, _getWidth["default"])(tableRef === null || tableRef === void 0 ? void 0 : tableRef.current);
    }

    if (prevWidth && prevWidth !== tableWidth.current) {
      scrollX.current = 0;
      onTableWidthChange === null || onTableWidthChange === void 0 ? void 0 : onTableWidthChange(prevWidth);
    }

    setOffsetByAffix();
  }, [onTableWidthChange, setOffsetByAffix, tableRef]);
  (0, _useMount["default"])(function () {
    calculateTableContextHeight();
    calculateTableContentWidth();
    calculateTableWidth();
    setOffsetByAffix();
    resizeObserver.current = new _resizeObserver.ResizeObserver(function (entries) {
      for (var _iterator = _createForOfIteratorHelperLoose(entries), _step; !(_step = _iterator()).done;) {
        var entry = _step.value;
        calculateTableWidth(entry.contentRect.width);
      }
    });
    resizeObserver.current.observe(tableRef === null || tableRef === void 0 ? void 0 : tableRef.current);
  });
  (0, _useUpdateLayoutEffect["default"])(function () {
    calculateTableWidth();
    calculateTableContextHeight();
    calculateTableContentWidth();
  }, [data, height, contentHeight, expandedRowKeys, children, calculateTableContextHeight, calculateTableContentWidth]);
  (0, _react.useEffect)(function () {
    return function () {
      var _resizeObserver$curre;

      (_resizeObserver$curre = resizeObserver.current) === null || _resizeObserver$curre === void 0 ? void 0 : _resizeObserver$curre.disconnect();
    };
  }, []);
  var setScrollY = (0, _react.useCallback)(function (value) {
    scrollY.current = value;
  }, []);
  var setScrollX = (0, _react.useCallback)(function (value) {
    scrollX.current = value;
  }, []);
  return {
    contentHeight: contentHeight,
    contentWidth: contentWidth,
    minScrollY: minScrollY,
    minScrollX: minScrollX,
    scrollY: scrollY,
    scrollX: scrollX,
    tableWidth: tableWidth,
    headerOffset: headerOffset,
    tableOffset: tableOffset,
    setScrollY: setScrollY,
    setScrollX: setScrollX
  };
};

var _default = useTableDimension;
exports["default"] = _default;